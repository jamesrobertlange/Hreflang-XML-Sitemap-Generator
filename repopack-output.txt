This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-10-22T16:33:06.226Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
templates/
  index.html
  success.html
uploads/
  20241022_Ariat_Homepages_-_Homepage_Overview_homepage.csv
.gitattributes
app.py
README.md

================================================================
Repository Files
================================================================

================
File: templates/index.html
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sitemap Generator</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: black;
            color: purple;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
        }
        .container {
            background-color: #111;
            padding: 2rem;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(128, 0, 128, 0.3);
            width: 100%;
            max-width: 600px;
        }
        h1 {
            text-align: center;
        }
        form {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        input[type="file"], select {
            color: purple;
            background-color: #222;
            border: 1px solid purple;
            padding: 0.5rem;
            border-radius: 5px;
            width: 100%;
        }
        input[type="submit"] {
            background-color: purple;
            color: black;
            border: none;
            padding: 0.5rem;
            cursor: pointer;
            font-weight: bold;
            border-radius: 5px;
        }
        input[type="submit"]:hover {
            background-color: #a020f0;
        }
        #progress-container {
            display: none;
            margin-top: 1rem;
        }
        #progress-bar {
            width: 100%;
            background-color: #ddd;
            border-radius: 5px;
        }
        #progress {
            width: 0%;
            height: 30px;
            background-color: purple;
            border-radius: 5px;
            text-align: center;
            line-height: 30px;
            color: white;
        }
        .file-section {
            margin-bottom: 1rem;
        }
        .file-section h3 {
            margin-bottom: 0.5rem;
        }
        .flash-messages {
            margin-bottom: 1rem;
        }
        .flash-message {
            padding: 1rem;
            margin-bottom: 0.5rem;
            border-radius: 5px;
            background-color: #222;
            border: 1px solid purple;
            color: purple;
        }
    </style>
</head>
<body>
    <div class="container">
        {% with messages = get_flashed_messages() %}
            {% if messages %}
            <div class="flash-messages">
                {% for message in messages %}
                <div class="flash-message">{{ message }}</div>
                {% endfor %}
            </div>
            {% endif %}
        {% endwith %}
        <h1>Sitemap Generator</h1>
        <form method="post" enctype="multipart/form-data" id="sitemap-form">
            <div class="form-section">
                <h3>Domain:</h3>
                <input type="text" name="domain" id="domain" required 
                       placeholder="e.g., ariat.com" 
                       pattern="^[a-zA-Z0-9][a-zA-Z0-9-_.]+\.[a-zA-Z]{2,}$"
                       title="Please enter a valid domain name"
                       class="form-input">
            </div>
            
            <div class="form-section">
                <h3>CSV Format:</h3>
                <select name="csv_type" id="csv_type" class="form-input">
                    <option value="standard">Standard Format</option>
                    <option value="all">Simple Format (URL + Indexable)</option>
                </select>
            </div>

            <div class="file-section">
                <h3>Homepage CSV:</h3>
                <select name="homepage_select">
                    <option value="">Select a previously uploaded file</option>
                    {% for file in homepage_files %}
                    <option value="{{ file }}">{{ file }}</option>
                    {% endfor %}
                </select>
                <p>Or upload a new file:</p>
                <input type="file" name="homepage_file" id="homepage_file">
            </div>

            <div class="file-section">
                <h3>Internal Pages CSV:</h3>
                <select name="internal_select">
                    <option value="">Select a previously uploaded file</option>
                    {% for file in internal_files %}
                    <option value="{{ file }}">{{ file }}</option>
                    {% endfor %}
                </select>
                <p>Or upload a new file:</p>
                <input type="file" name="internal_file" id="internal_file">
            </div>

            <input type="submit" value="Generate Sitemaps">
        </form>
        <div id="progress-container">
            <h3 id="status"></h3>
            <div id="progress-bar">
                <div id="progress"></div>
            </div>
        </div>
    </div>
    <script>
        document.getElementById('sitemap-form').addEventListener('submit', function(e) {
    e.preventDefault();
    var formData = new FormData(this);
    var xhr = new XMLHttpRequest();
    
    // Show progress container
    document.getElementById('progress-container').style.display = 'block';
    
    xhr.open('POST', '/', true);
    xhr.onload = function() {
        try {
            var response = JSON.parse(xhr.responseText);
            if (xhr.status === 200 && response.status === 'success') {
                window.location.href = response.redirect;
            } else {
                document.getElementById('status').textContent = 'Error: ' + response.message;
                document.getElementById('progress').style.width = '0%';
                document.getElementById('progress').textContent = '0%';
            }
        } catch (e) {
            document.getElementById('status').textContent = 'Error processing response';
            document.getElementById('progress').style.width = '0%';
            document.getElementById('progress').textContent = '0%';
        }
    };
    
    xhr.onerror = function() {
        document.getElementById('status').textContent = 'Network error occurred';
        document.getElementById('progress').style.width = '0%';
        document.getElementById('progress').textContent = '0%';
    };
    
    xhr.send(formData);
    updateProgress();
});

        function updateProgress() {
            fetch('/progress')
                .then(response => response.json())
                .then(data => {
                    document.getElementById('status').textContent = data.status;
                    document.getElementById('progress').style.width = data.percentage + '%';
                    document.getElementById('progress').textContent = data.percentage + '%';
                    if (data.percentage < 100 && data.status !== 'Error') {
                        setTimeout(updateProgress, 1000);
                    }
                })
                .catch(error => {
                    console.error('Error fetching progress:', error);
                    document.getElementById('status').textContent = 'Error updating progress';
                });
        }
    </script>
</body>
</html>

================
File: templates/success.html
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sitemap Generation Success</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: black;
            color: purple;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
        }
        .container {
            background-color: #111;
            padding: 2rem;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(128, 0, 128, 0.3);
            text-align: center;
        }
        h1 {
            margin-bottom: 1rem;
        }
        .flash-messages {
            margin-bottom: 1rem;
        }
        .flash-message {
            padding: 0.5rem;
            margin: 0.5rem 0;
            border-radius: 5px;
            background-color: #222;
            border: 1px solid purple;
        }
        a {
            color: #a020f0;
            text-decoration: none;
            display: inline-block;
            margin: 0.5rem;
            padding: 0.5rem 1rem;
            background-color: purple;
            color: black;
            border-radius: 5px;
        }
        a:hover {
            background-color: #a020f0;
        }
    </style>
</head>
<body>
    <div class="container">
        {% with messages = get_flashed_messages() %}
            {% if messages %}
            <div class="flash-messages">
                {% for message in messages %}
                <div class="flash-message">{{ message }}</div>
                {% endfor %}
            </div>
            {% endif %}
        {% endwith %}
        
        <h1>Sitemaps Generated Successfully!</h1>
        <p>Your sitemaps have been generated and saved.</p>
        <a href="/download_compressed">Download Compressed Sitemaps</a>
        <a href="/download_raw">Download Raw Sitemaps</a>
        <a href="/download_csv">Download All Links CSV</a>
        <br><br>
        <a href="/">Generate More Sitemaps</a>
    </div>
</body>
</html>

================
File: uploads/20241022_Ariat_Homepages_-_Homepage_Overview_homepage.csv
================
Homepage,Country,Language,Language Default,Country (Long),Language (Long)
https://www.ariat.com/,us,en,Y,United States of America,English
https://www.ariat.com/at/de/,at,de,,Austria,German
https://www.ariat.com/be/en/,be,en,,Belgium,English
https://www.ariat.com/ch/de/,ch,de,,Switzerland,German
https://www.ariat.com/de/de/,de,de,Y,Germany,German
https://www.ariat.com/dk/en/,dk,en,,Denmark,English
https://www.ariat.com/fi/en/,fi,en,,Finland,English
https://www.ariat.com/fr/fr/,fr,fr,Y,France,French
https://www.ariat.com/gb/en/,gb,en,,United Kingdom of Great Britain and Northern Ireland,English
https://www.ariat.com/ie/en/,ie,en,,Ireland,English
https://www.ariat.com/it/en/,it,en,,Italy,English
https://www.ariat.com/nl/en/,nl,en,,"Netherlands, Kingdom of the",English
https://www.ariat.com/no/en/,no,en,,Norway,English
https://www.ariat.com/se/en/,se,en,,Sweden,English

================
File: .gitattributes
================
# Auto detect text files and perform LF normalization
* text=auto

================
File: app.py
================
from flask import Flask, render_template, request, send_file, redirect, url_for, jsonify, flash
from werkzeug.utils import secure_filename
import os
from datetime import datetime
import csv
from collections import defaultdict
import re
import gzip
from xml.etree.ElementTree import Element, SubElement, tostring
from xml.dom import minidom
import io
import zipfile
import time

app = Flask(__name__)
app.secret_key = os.urandom(24)

# Ensure necessary folders exist
UPLOAD_FOLDER = 'uploads'
OUTPUT_FOLDER = 'xml_sitemaps'
RAW_OUTPUT_FOLDER = 'raw_xml_sitemaps'
CSV_FOLDER = 'csv_output'
for folder in [UPLOAD_FOLDER, OUTPUT_FOLDER, RAW_OUTPUT_FOLDER, CSV_FOLDER]:
    if not os.path.exists(folder):
        os.makedirs(folder)

app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
app.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # 16MB max file size

# Global variable to store progress
progress = {"status": "Not started", "percentage": 0}

def clear_output_folders():
    """Clear previous output files before new generation"""
    for folder in [OUTPUT_FOLDER, RAW_OUTPUT_FOLDER]:
        for file in os.listdir(folder):
            file_path = os.path.join(folder, file)
            try:
                if os.path.isfile(file_path):
                    os.unlink(file_path)
            except Exception as e:
                print(f"Error deleting {file_path}: {e}")

def parse_internal_csv(file_path, domain, csv_type='all'):
    """
    Parse the internal pages CSV file.
    Handles both CSV files with headers and without headers.
    """
    pages = defaultdict(list)
    try:
        with open(file_path, 'r', encoding='utf-8-sig') as csvfile:
            # Read the first line to check for separator specification
            first_line = csvfile.readline().strip()
            csvfile.seek(0)
            
            # Skip separator line if present
            if first_line.startswith('sep='):
                next(csvfile)
                first_line = csvfile.readline().strip()
                csvfile.seek(0)
                next(csvfile)  # Skip the separator line again
            
            # Check if the first line might be headers
            has_headers = 'url' in first_line.lower() or 'address' in first_line.lower() or 'full' in first_line.lower()
            
            if has_headers:
                reader = csv.DictReader(csvfile)
                # Normalize fieldnames
                fieldnames = reader.fieldnames
                normalized_fieldnames = {col: col.lower().replace(' ', '') for col in fieldnames}
                
                # Find the URL and indexability columns
                url_columns = ['fullurl', 'address', 'url']
                indexable_columns = ['isindexable', 'indexability', 'indexable']
                
                address_column = next((col for col, norm in normalized_fieldnames.items() 
                                    if norm in url_columns), None)
                indexability_column = next((col for col, norm in normalized_fieldnames.items() 
                                         if norm in indexable_columns), None)
                
                if not address_column or not indexability_column:
                    # Fallback to treating as no headers
                    csvfile.seek(0)
                    if first_line.startswith('sep='):
                        next(csvfile)
                    reader = csv.reader(csvfile)
                    has_headers = False
            else:
                reader = csv.reader(csvfile)
            
            # Process the CSV
            row_count = 0
            for row in reader:
                try:
                    if has_headers:
                        url = row[address_column].strip()
                        indexability = str(row[indexability_column]).strip().lower()
                    else:
                        if len(row) < 2:
                            print(f"Skipping invalid row: {row}")
                            continue
                        url = row[0].strip()
                        indexability = str(row[1]).strip().lower()
                    
                    # Check if the URL is indexable
                    if indexability not in ['true', 'indexable', 'yes', 'y', '1']:
                        continue
                    
                    # Skip empty URLs
                    if not url:
                        continue
                    
                    # Handle URLs with or without domain
                    if domain not in url.lower():
                        if url.startswith('/'):
                            url = f"https://{domain}{url}"
                        else:
                            url = f"https://{domain}/{url}"
                    
                    # Extract path
                    domain_pattern = re.escape(domain)
                    path_match = re.search(f"https?://(?:www\.)?{domain_pattern}(/.*)?", url, re.IGNORECASE)
                    
                    if path_match:
                        path = path_match.group(1) or '/'
                        base_url = url.split(path)[0].rstrip('/')
                        pages[base_url.lower()].append((url, path))
                        row_count += 1
                    
                except Exception as e:
                    print(f"Error processing row: {row}")
                    print(f"Error details: {str(e)}")
                    continue
            
            print(f"Successfully processed {row_count} URLs")
            return pages
            
    except Exception as e:
        raise ValueError(f"Error parsing internal CSV: {str(e)}")

def parse_homepage_csv(file_path):
    """Parse the homepage CSV file."""
    homepages = defaultdict(dict)
    try:
        with open(file_path, 'r', encoding='utf-8-sig') as csvfile:
            # Read the first line to check for separator specification
            first_line = csvfile.readline().strip()
            
            # If it's a separator line, reset file pointer and skip first line
            if first_line.startswith('sep='):
                csvfile.seek(0)
                next(csvfile)  # Skip the separator line
            else:
                # If it's not a separator line, reset to start
                csvfile.seek(0)
            
            reader = csv.DictReader(csvfile)
            fieldnames = reader.fieldnames
            
            # Check for required columns with flexible naming
            homepage_col = next((col for col in fieldnames if col.lower() in ['homepage', 'url', 'address']), None)
            country_col = next((col for col in fieldnames if col.lower() in ['country', 'country code']), None)
            language_col = next((col for col in fieldnames if col.lower() in ['language', 'language code']), None)
            locale_col = next((col for col in fieldnames if col.lower() in ['locale', 'language tag']), None)
            default_col = next((col for col in fieldnames if col.lower() in ['language default', 'is default', 'default']), None)
            
            if not all([homepage_col, country_col, language_col]):
                available_columns = ", ".join(fieldnames)
                raise ValueError(f"Required columns missing. Need Homepage/URL, Country, and Language columns. Found columns: {available_columns}")
            
            for row in reader:
                url = row[homepage_col].rstrip('/')
                country = row[country_col].lower()
                language = row[language_col].lower()
                # Handle optional locale column
                locale = row[locale_col].lower() if locale_col else f"{language}_{country}"
                # Handle optional default column
                is_default = row.get(default_col, '').upper() == 'Y' if default_col else False
                
                key = f"{language}-{country}" if not is_default else language
                homepages[key] = {
                    'url': url,
                    'is_default': is_default,
                    'country': country,
                    'language': language,
                    'locale': locale
                }
                
        return homepages
        
    except Exception as e:
        raise ValueError(f"Error parsing homepage CSV: {str(e)}")

def get_uploaded_files():
    homepage_files = [f for f in os.listdir(UPLOAD_FOLDER) if f.endswith('_homepage.csv')]
    internal_files = [f for f in os.listdir(UPLOAD_FOLDER) if f.endswith('_internal.csv')]
    return homepage_files, internal_files

def get_url_sitemap_mapping(homepages, pages):
    """
    Maps URLs to their appropriate sitemaps based on homepage configurations.
    """
    # Convert pages list to a set of URLs for faster lookup
    all_urls = {url for url, _ in pages}
    
    # Create mapping of base paths to their alternates
    path_mapping = {}
    for url, path in pages:
        # Extract the path without country/language prefix
        country_lang_match = re.match(r'https://[^/]+/(?:[a-z]{2}/[a-z]{2})?(.*)', url)
        if country_lang_match:
            base_path = country_lang_match.group(1).strip('/')
            if base_path not in path_mapping:
                path_mapping[base_path] = set()
            path_mapping[base_path].add(url)

    # Organize pages by sitemap
    mapped_pages = defaultdict(list)
    
    for lang_region, homepage in homepages.items():
        base_url = homepage['url'].rstrip('/')
        country = homepage['country']
        lang = homepage['language']
        
        # Pattern for this region's URLs
        regional_prefix = f"{base_url}/{country}/{lang}/"
        
        # Add pages that match this region's pattern
        for url, path in pages:
            if url.startswith(regional_prefix) or (country == 'us' and lang == 'en' and not any(
                url.startswith(f"{h['url'].rstrip('/')}/{h['country']}/{h['language']}/")
                for h in homepages.values() if h != homepage
            )):
                mapped_pages[base_url].append((url, path))

    return mapped_pages, path_mapping

def generate_sitemap(homepage, pages, all_homepages, path_mapping):
    """Generate a sitemap for a specific homepage and its pages."""
    urlset = Element('urlset', {
        'xmlns': 'http://www.sitemaps.org/schemas/sitemap/0.9',
        'xmlns:xhtml': 'http://www.w3.org/1999/xhtml'
    })

    links = []

    # Add homepage
    url_elem = SubElement(urlset, 'url')
    loc = SubElement(url_elem, 'loc')
    loc.text = homepage['url'].rstrip('/') + '/'
    
    # Add hreflang entries for homepage
    for lang_region, home in all_homepages.items():
        if home['is_default']:
            hreflang = lang_region
        else:
            hreflang = f"{home['language']}-{home['country']}"
        
        link = SubElement(url_elem, 'xhtml:link', {
            'rel': 'alternate',
            'hreflang': hreflang,
            'href': home['url'].rstrip('/') + '/'
        })
        
        sitemap_id = f"{homepage['country']}_{homepage['language']}_{homepage['locale']}"
        links.append((home['url'].rstrip('/') + '/', sitemap_id, hreflang))

    # Add internal pages
    added_urls = set([homepage['url'].rstrip('/') + '/'])
    
    for full_url, path in pages:
        if full_url not in added_urls:
            # Get base path for finding alternates
            country_lang_match = re.match(r'https://[^/]+/(?:[a-z]{2}/[a-z]{2})?(.*)', full_url)
            if not country_lang_match:
                continue
                
            base_path = country_lang_match.group(1).strip('/')
            if not base_path:
                continue

            url_elem = SubElement(urlset, 'url')
            loc = SubElement(url_elem, 'loc')
            loc.text = full_url
            added_urls.add(full_url)

            # Add hreflang entries only for existing URLs
            alternates = path_mapping.get(base_path, set())
            
            for lang_region, home in all_homepages.items():
                if home['is_default']:
                    hreflang = lang_region
                else:
                    hreflang = f"{home['language']}-{home['country']}"
                
                # Construct the potential alternate URL
                if home['country'] == 'us' and home['language'] == 'en':
                    alt_url = f"{home['url'].rstrip('/')}/{base_path}"
                else:
                    alt_url = f"{home['url'].rstrip('/')}/{home['country']}/{home['language']}/{base_path}"
                
                # Only add alternate if it exists in our input data
                if alt_url in alternates:
                    link = SubElement(url_elem, 'xhtml:link', {
                        'rel': 'alternate',
                        'hreflang': hreflang,
                        'href': alt_url
                    })
                    
                    sitemap_id = f"{homepage['country']}_{homepage['language']}_{homepage['locale']}"
                    links.append((alt_url, sitemap_id, hreflang))

    return urlset, links

def generate_sitemaps(homepages, pages):
    """
    Generate all sitemaps with proper URL mapping.
    """
    # Map URLs to appropriate sitemaps and get path mapping
    mapped_pages, path_mapping = get_url_sitemap_mapping(homepages, [
        (url, path) for base_url, url_list in pages.items() 
        for url, path in url_list
    ])
    
    sitemap_files = []
    all_links = []
    today = datetime.now().strftime("%Y%m%d")

    for lang_region, homepage in homepages.items():
        base_url = homepage['url'].rstrip('/')
        
        # Get pages for this sitemap
        sitemap_pages = mapped_pages.get(base_url, [])
        
        # Generate sitemap
        urlset, links = generate_sitemap(homepage, sitemap_pages, homepages, path_mapping)
        all_links.extend(links)
        
        # Save sitemap
        filename = f"sitemap_{today}_{homepage['country']}_{homepage['language']}_{homepage['locale']}.xml.gz"
        raw_filename = f"sitemap_{today}_{homepage['country']}_{homepage['language']}_{homepage['locale']}.xml"
        
        sitemap_path = os.path.join(OUTPUT_FOLDER, filename)
        raw_sitemap_path = os.path.join(RAW_OUTPUT_FOLDER, raw_filename)
        
        save_sitemap(urlset, sitemap_path, raw_sitemap_path)
        sitemap_files.append((filename, raw_filename))
    
    return sitemap_files, all_links

def save_sitemap(urlset, filename, raw_filename):
    """Save sitemap in both raw and compressed formats."""
    rough_string = tostring(urlset, 'utf-8')
    reparsed = minidom.parseString(rough_string)
    pretty_xml = reparsed.toprettyxml(indent="  ")
    
    # Save uncompressed XML
    with open(raw_filename, 'w', encoding='utf-8') as f:
        f.write(pretty_xml)
    
    # Save gzipped XML
    with gzip.open(filename, 'wt', encoding='utf-8') as f:
        f.write(pretty_xml)

def create_zip_file(source_folder, zip_filename):
    """Create a zip file from a folder."""
    memory_file = io.BytesIO()
    with zipfile.ZipFile(memory_file, 'w', zipfile.ZIP_DEFLATED) as zf:
        for root, dirs, files in os.walk(source_folder):
            for file in files:
                zf.write(os.path.join(root, file), file)
    memory_file.seek(0)
    return send_file(
        memory_file,
        download_name=zip_filename,
        as_attachment=True,
        mimetype='application/zip'
    )

@app.route('/', methods=['GET', 'POST'])
def index():
    if request.method == 'POST':
        try:
            # Reset progress and clear previous outputs
            global progress
            progress = {"status": "Starting", "percentage": 0}
            clear_output_folders()

            domain = request.form.get('domain', '').strip()
            csv_type = request.form.get('csv_type', 'standard')
            
            if not domain:
                raise ValueError('Please enter a domain name')

            # Handle file uploads/selection
            homepage_file = request.files.get('homepage_file')
            internal_file = request.files.get('internal_file')
            homepage_select = request.form.get('homepage_select')
            internal_select = request.form.get('internal_select')

            # Process homepage file
            if homepage_file and homepage_file.filename:
                homepage_filename = f"{datetime.now().strftime('%Y%m%d')}_{secure_filename(homepage_file.filename.rsplit('.', 1)[0])}_homepage.csv"
                homepage_path = os.path.join(app.config['UPLOAD_FOLDER'], homepage_filename)
                homepage_file.save(homepage_path)
            elif homepage_select:
                homepage_path = os.path.join(app.config['UPLOAD_FOLDER'], homepage_select)
            else:
                raise ValueError('Please upload or select a homepage file')

            # Process internal file
            if internal_file and internal_file.filename:
                internal_filename = f"{datetime.now().strftime('%Y%m%d')}_{secure_filename(internal_file.filename.rsplit('.', 1)[0])}_internal.csv"
                internal_path = os.path.join(app.config['UPLOAD_FOLDER'], internal_filename)
                internal_file.save(internal_path)
            elif internal_select:
                internal_path = os.path.join(app.config['UPLOAD_FOLDER'], internal_select)
            else:
                raise ValueError('Please upload or select an internal pages file')

            # Process files and generate sitemaps
            progress["status"] = "Parsing homepage data..."
            progress["percentage"] = 10
            homepages = parse_homepage_csv(homepage_path)
            
            progress["status"] = "Parsing internal pages..."
            progress["percentage"] = 20
            internal_pages = parse_internal_csv(internal_path, domain, csv_type)
            
            progress["status"] = "Generating sitemaps..."
            progress["percentage"] = 40

            # Generate sitemaps with the new mapping logic
            sitemap_files, all_links = generate_sitemaps(homepages, internal_pages)

            # Save all links to CSV
            today = datetime.now().strftime("%Y%m%d")
            csv_filename = os.path.join(CSV_FOLDER, f"all_links_{today}.csv")
            with open(csv_filename, 'w', newline='', encoding='utf-8') as csvfile:
                writer = csv.writer(csvfile)
                writer.writerow(['URL', 'Sitemap', 'Hreflang'])
                writer.writerows(all_links)

            progress["status"] = "Complete"
            progress["percentage"] = 100

            flash('Sitemaps generated successfully!')
            return jsonify({"status": "success", "redirect": url_for('success')})

        except Exception as e:
            progress["status"] = "Error"
            progress["percentage"] = 0
            flash(str(e))
            return jsonify({"status": "error", "message": str(e)}), 400

    # GET request
    homepage_files, internal_files = get_uploaded_files()
    return render_template('index.html', homepage_files=homepage_files, internal_files=internal_files)

@app.route('/progress')
def get_progress():
    return jsonify(progress)

@app.route('/success')
def success():
    return render_template('success.html')

@app.route('/download_compressed')
def download_compressed():
    try:
        if not os.path.exists(OUTPUT_FOLDER) or not os.listdir(OUTPUT_FOLDER):
            flash('No compressed sitemaps found. Please generate the sitemaps first.')
            return redirect(url_for('index'))
        return create_zip_file(OUTPUT_FOLDER, 'compressed_sitemaps.zip')
    except Exception as e:
        flash(f'Error downloading compressed sitemaps: {str(e)}')
        return redirect(url_for('index'))

@app.route('/download_raw')
def download_raw():
    try:
        if not os.path.exists(RAW_OUTPUT_FOLDER) or not os.listdir(RAW_OUTPUT_FOLDER):
            flash('No raw sitemaps found. Please generate the sitemaps first.')
            return redirect(url_for('index'))
        return create_zip_file(RAW_OUTPUT_FOLDER, 'raw_sitemaps.zip')
    except Exception as e:
        flash(f'Error downloading raw sitemaps: {str(e)}')
        return redirect(url_for('index'))

@app.route('/download_csv')
def download_csv():
    try:
        today = datetime.now().strftime("%Y%m%d")
        csv_filename = f"all_links_{today}.csv"
        csv_path = os.path.join(CSV_FOLDER, csv_filename)
        
        if not os.path.exists(csv_path):
            flash('No CSV file found. Please generate the sitemaps first.')
            return redirect(url_for('index'))
        
        return send_file(
            csv_path,
            download_name=csv_filename,
            as_attachment=True,
            mimetype='text/csv'
        )
    except Exception as e:
        flash(f'Error downloading CSV: {str(e)}')
        return redirect(url_for('index'))

if __name__ == '__main__':
    # Ensure the upload and output directories exist
    for directory in [UPLOAD_FOLDER, OUTPUT_FOLDER, RAW_OUTPUT_FOLDER]:
        if not os.path.exists(directory):
            os.makedirs(directory)
    
    # Run the Flask application
    app.run(debug=True, host='0.0.0.0', port=5000)

================
File: README.md
================
# Hreflang XML Sitemap Generator

## Overview

The Hreflang XML Sitemap Generator is a Flask-based web application that automates the process of generating XML sitemaps with hreflang tags for multilingual websites. This tool is particularly useful for SEO professionals and web developers managing websites with multiple language versions.

## Links
- [Homepage link](https://drive.google.com/file/d/155DMCjf4kM9KwmhEzirGtIqXphPKQfMy/view?usp=drive_link)
- [Crawl Link](https://drive.google.com/file/d/1n_N5bocFNaMgZcth9XoN9KBGMXh-m3GY/view?usp=drive_link)
- [Output Examples](https://drive.google.com/drive/folders/15AAGBLH-e0nWXPbMGIs_SmNSU63AIAzB?usp=sharing)

## Features

- Upload or select previously uploaded CSV files for homepage and internal pages
- Generate XML sitemaps with hreflang tags
- Create both compressed (gzipped) and raw XML sitemaps
- Generate a comprehensive CSV file containing all links, their corresponding sitemaps, and hreflang codes
- Progress tracking during sitemap generation
- Download options for compressed sitemaps, raw sitemaps, and the all-links CSV file

## Requirements

- Python 3.7+
- Flask
- Werkzeug
- tqdm

## Installation

1. Clone the repository:
   ```
   git clone https://github.com/your-username/hreflang-xml-sitemap-generator.git
   cd hreflang-xml-sitemap-generator
   ```

2. Create a virtual environment (optional but recommended):
   ```
   python -m venv venv
   source venv/bin/activate  # On Windows, use `venv\Scripts\activate`
   ```

3. Install the required dependencies:
   ```
   pip install flask werkzeug tqdm
   ```

## Usage

1. Start the Flask application:
   ```
   python app.py
   ```

2. Open a web browser and navigate to `http://127.0.0.1:5000/`

3. Use the web interface to:
   - Upload new CSV files or select previously uploaded files for homepage and internal pages
   - Generate sitemaps
   - Download the resulting files (compressed sitemaps, raw sitemaps, and all-links CSV)

## CSV File Format

### Homepage CSV
The homepage CSV should contain the following columns:
- Homepage: The URL of the homepage
- Country: The country code
- Language: The language code
- Locale: The locale code
- Language Default: 'Y' if it's the default language, 'N' otherwise

### Internal Pages CSV
The internal pages CSV should contain the following columns:
- Address: The URL of the internal page
- Indexability: 'indexable' for pages that should be included in the sitemap

## Output

The application generates three types of output:
1. Compressed XML sitemaps (`.xml.gz` files)
2. Raw XML sitemaps (`.xml` files)
3. A CSV file containing all links, their corresponding sitemaps, and hreflang codes

## Contributing

Contributions to improve the Hreflang XML Sitemap Generator are welcome. Please feel free to submit pull requests or create issues for bugs and feature requests.

## License

[MIT License](LICENSE)

## Disclaimer

This tool is provided as-is, without any warranties. Always verify the generated sitemaps before using them in a production environment.
